#!/usr/bin/env python3
"""
Test Validator for Bedfordshire Lace Extension

This script validates SVG files generated by the extension to verify:
- Metadata structure is correct
- Connection tracking works
- Pricking points are properly colored
- Transforms are applied correctly
- Element counts and types match expectations
"""

import sys
import json
import xml.etree.ElementTree as ET
from math import hypot


class LaceTestValidator:
    """Validates generated lace patterns."""

    def __init__(self, svg_file):
        """Load SVG file for validation."""
        self.tree = ET.parse(svg_file)
        self.root = self.tree.getroot()
        self.ns = {'svg': 'http://www.w3.org/2000/svg',
                   'inkscape': 'http://www.inkscape.org/namespaces/inkscape'}
        self.errors = []
        self.warnings = []

    def validate_all(self):
        """Run all validation checks."""
        print("=" * 60)
        print("Bedfordshire Lace Extension - Test Validator")
        print("=" * 60)

        self.check_lace_layer_exists()
        elements = self.find_all_lace_elements()

        print(f"\nFound {len(elements)} lace elements")

        for elem_group in elements:
            self.validate_element(elem_group)

        self.validate_connections()
        self.validate_pricking_colors()

        self.print_summary()

    def check_lace_layer_exists(self):
        """Verify 'Lace Pattern' layer exists."""
        layers = self.root.findall('.//svg:g[@inkscape:groupmode="layer"]', self.ns)
        lace_layer = None

        for layer in layers:
            label = layer.get(f'{{{self.ns["inkscape"]}}}label')
            if label == "Lace Pattern":
                lace_layer = layer
                break

        if lace_layer is None:
            self.errors.append("'Lace Pattern' layer not found")
        else:
            print("✓ 'Lace Pattern' layer exists")

    def find_all_lace_elements(self):
        """Find all groups with lace metadata."""
        elements = []

        for group in self.root.findall('.//svg:g', self.ns):
            metadata_str = group.get('data-lace-metadata')
            if metadata_str:
                try:
                    metadata = json.loads(metadata_str)
                    elements.append({
                        'group': group,
                        'metadata': metadata,
                        'id': group.get('id')
                    })
                except json.JSONDecodeError as e:
                    self.errors.append(f"Invalid JSON in element {group.get('id')}: {e}")

        return elements

    def validate_element(self, elem_data):
        """Validate a single lace element."""
        metadata = elem_data['metadata']
        elem_id = elem_data['id']
        elem_type = metadata.get('element_type')

        print(f"\n--- Validating {elem_type} (ID: {elem_id}) ---")

        # Check required fields for all elements
        required_fields = ['element_type', 'control_path_id', 'pairs']
        for field in required_fields:
            if field not in metadata:
                self.errors.append(f"{elem_id}: Missing required field '{field}'")
            else:
                print(f"  ✓ {field}: {metadata[field]}")

        # Type-specific validation
        if elem_type == 'tape':
            self.validate_tape(elem_id, metadata)
        elif elem_type in ['tally_rect', 'tally_leaf']:
            self.validate_tally(elem_id, metadata, elem_type)
        elif elem_type == 'plait':
            self.validate_plait(elem_id, metadata)
        elif elem_type == 'leaf':
            self.validate_leaf(elem_id, metadata)
        else:
            self.errors.append(f"{elem_id}: Unknown element type '{elem_type}'")

    def validate_tape(self, elem_id, metadata):
        """Validate tape-specific metadata."""
        required = ['initial_pairs', 'current_pairs', 'base_width_mm', 'splits', 'pricking_ports']

        for field in required:
            if field not in metadata:
                self.errors.append(f"{elem_id}: Missing tape field '{field}'")

        # Validate pricking_ports structure
        pricking_ports = metadata.get('pricking_ports', [])
        print(f"  ✓ Pricking ports: {len(pricking_ports)}")

        for i, port in enumerate(pricking_ports):
            if not isinstance(port, dict):
                self.errors.append(f"{elem_id}: pricking_ports[{i}] is not a dict")
                continue

            port_fields = ['point', 'edge', 't', 'index', 'is_active']
            for field in port_fields:
                if field not in port:
                    self.errors.append(f"{elem_id}: pricking_ports[{i}] missing '{field}'")

            # Validate point coordinates
            point = port.get('point')
            if not isinstance(point, (list, tuple)) or len(point) != 2:
                self.errors.append(f"{elem_id}: pricking_ports[{i}] point is not [x, y]")

            # Validate edge
            edge = port.get('edge')
            if edge not in ['left', 'right']:
                self.errors.append(f"{elem_id}: pricking_ports[{i}] edge must be 'left' or 'right'")

        # Check alternating pattern
        edges = [p.get('edge') for p in pricking_ports]
        alternates = True
        for i in range(len(edges) - 1):
            if edges[i] == edges[i+1]:
                alternates = False
                break

        if alternates and len(edges) > 1:
            print(f"  ✓ Pricking alternates left/right")
        elif len(edges) > 1:
            self.warnings.append(f"{elem_id}: Pricking points don't alternate")

    def validate_tally(self, elem_id, metadata, elem_type):
        """Validate tally-specific metadata."""
        required = ['width', 'height', 'entry_point', 'exit_point', 'connection_points']

        for field in required:
            if field not in metadata:
                self.errors.append(f"{elem_id}: Missing tally field '{field}'")

        # Validate points
        for point_name in ['entry_point', 'exit_point']:
            point = metadata.get(point_name)
            if not isinstance(point, (list, tuple)) or len(point) != 2:
                self.errors.append(f"{elem_id}: {point_name} is not [x, y]")
            else:
                print(f"  ✓ {point_name}: ({point[0]:.1f}, {point[1]:.1f})")

        # Validate connection points count
        conn_points = metadata.get('connection_points', [])
        expected_count = 4 if elem_type == 'tally_rect' else 2
        if len(conn_points) != expected_count:
            self.errors.append(
                f"{elem_id}: Expected {expected_count} connection_points, got {len(conn_points)}"
            )
        else:
            print(f"  ✓ Connection points: {len(conn_points)}")

    def validate_plait(self, elem_id, metadata):
        """Validate plait-specific metadata."""
        required = ['has_picots', 'start_point', 'end_point', 'connection_points']

        for field in required:
            if field not in metadata:
                self.errors.append(f"{elem_id}: Missing plait field '{field}'")

        # Validate points
        for point_name in ['start_point', 'end_point']:
            point = metadata.get(point_name)
            if not isinstance(point, (list, tuple)) or len(point) != 2:
                self.errors.append(f"{elem_id}: {point_name} is not [x, y]")

        # Validate connection metadata
        for conn_name in ['start_connection', 'end_connection']:
            conn = metadata.get(conn_name)
            if conn is not None:
                print(f"  ✓ {conn_name}: Connected to {conn.get('element_type')} " +
                      f"at pricking {conn.get('pricking_index')}")

                # Validate connection structure
                conn_fields = ['point', 'element_id', 'control_path_id',
                              'element_type', 'pricking_index']
                for field in conn_fields:
                    if field not in conn:
                        self.errors.append(
                            f"{elem_id}: {conn_name} missing field '{field}'"
                        )
            else:
                print(f"  ✓ {conn_name}: None (standalone)")

        # Validate picots
        has_picots = metadata.get('has_picots', False)
        print(f"  ✓ Picots: {'Yes' if has_picots else 'No'}")

    def validate_leaf(self, elem_id, metadata):
        """Validate leaf-specific metadata."""
        required = ['pricking_points', 'entry_exit_point']

        for field in required:
            if field not in metadata:
                self.errors.append(f"{elem_id}: Missing leaf field '{field}'")

        # Validate pricking points
        pricking_points = metadata.get('pricking_points', [])
        print(f"  ✓ Pricking points: {len(pricking_points)}")

        for i, pp in enumerate(pricking_points):
            if not isinstance(pp, dict):
                self.errors.append(f"{elem_id}: pricking_points[{i}] is not a dict")
                continue

            pp_fields = ['point', 'index', 'is_active']
            for field in pp_fields:
                if field not in pp:
                    self.errors.append(f"{elem_id}: pricking_points[{i}] missing '{field}'")

    def validate_connections(self):
        """Validate connection consistency across elements."""
        print("\n--- Validating Connections ---")

        elements = self.find_all_lace_elements()

        # Build connection map
        connections = []

        for elem in elements:
            metadata = elem['metadata']
            elem_type = metadata.get('element_type')

            if elem_type == 'plait':
                # Check plait connections
                for conn_type in ['start_connection', 'end_connection']:
                    conn = metadata.get(conn_type)
                    if conn:
                        connections.append({
                            'plait_id': elem['id'],
                            'plait_control_id': metadata.get('control_path_id'),
                            'end': conn_type,
                            'target_control_id': conn.get('control_path_id'),
                            'target_type': conn.get('element_type'),
                            'pricking_index': conn.get('pricking_index')
                        })

        print(f"Found {len(connections)} plait connections")

        # Verify each connection has a matching target element
        for conn in connections:
            target_found = False

            for elem in elements:
                if elem['metadata'].get('control_path_id') == conn['target_control_id']:
                    target_found = True
                    print(f"  ✓ {conn['plait_id']} -> {elem['id']} " +
                          f"(pricking {conn['pricking_index']})")
                    break

            if not target_found:
                self.errors.append(
                    f"Connection target not found: {conn['plait_id']} -> " +
                    f"control_path_id={conn['target_control_id']}"
                )

    def validate_pricking_colors(self):
        """Validate pricking point colors (gray vs green)."""
        print("\n--- Validating Pricking Colors ---")

        # Find all circles and check their colors
        gray_count = 0
        green_count = 0
        other_count = 0

        for circle in self.root.findall('.//svg:circle', self.ns):
            style = circle.get('style', '')
            fill_color = None

            # Parse fill from style
            for prop in style.split(';'):
                prop = prop.strip()
                if prop.startswith('fill:'):
                    fill_color = prop.split(':')[1].strip()

            if fill_color == '#666666':
                gray_count += 1
            elif fill_color in ['#00FF00', '#00ff00', 'rgb(0,255,0)']:
                green_count += 1
            elif fill_color and fill_color != 'none':
                other_count += 1

        print(f"  Gray pricking points: {gray_count}")
        print(f"  Green pricking points: {green_count}")
        if other_count > 0:
            print(f"  Other colored points: {other_count}")

        # Validate that green count matches connection count
        elements = self.find_all_lace_elements()
        connection_count = 0

        for elem in elements:
            metadata = elem['metadata']
            elem_type = metadata.get('element_type')

            if elem_type == 'plait':
                if metadata.get('start_connection'):
                    connection_count += 1
                if metadata.get('end_connection'):
                    connection_count += 1

        if green_count == connection_count:
            print(f"  ✓ Green pricking count matches connections ({connection_count})")
        else:
            self.warnings.append(
                f"Green pricking count ({green_count}) doesn't match " +
                f"connection count ({connection_count})"
            )

    def print_summary(self):
        """Print validation summary."""
        print("\n" + "=" * 60)
        print("VALIDATION SUMMARY")
        print("=" * 60)

        if not self.errors and not self.warnings:
            print("✓ ALL TESTS PASSED - No errors or warnings!")
        else:
            if self.errors:
                print(f"\n❌ ERRORS ({len(self.errors)}):")
                for i, error in enumerate(self.errors, 1):
                    print(f"  {i}. {error}")

            if self.warnings:
                print(f"\n⚠ WARNINGS ({len(self.warnings)}):")
                for i, warning in enumerate(self.warnings, 1):
                    print(f"  {i}. {warning}")

        print("\n" + "=" * 60)

        # Return exit code
        return 0 if not self.errors else 1


def main():
    """Main entry point."""
    if len(sys.argv) != 2:
        print("Usage: python test_validator.py <svg_file>")
        print("\nThis script validates SVG files generated by the Bedfordshire Lace extension.")
        print("It checks metadata structure, connections, and visual elements.")
        sys.exit(1)

    svg_file = sys.argv[1]

    try:
        validator = LaceTestValidator(svg_file)
        exit_code = validator.validate_all()
        sys.exit(exit_code)
    except FileNotFoundError:
        print(f"Error: File '{svg_file}' not found")
        sys.exit(1)
    except ET.ParseError as e:
        print(f"Error: Invalid SVG file - {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
